package org.ndexbio.ndexsearch.rest.services; // Note your package will be {{ groupId }}.rest

import java.net.URI;
import com.fasterxml.jackson.core.JsonProcessingException;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.headers.Header;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import java.io.InputStream;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;
import org.ndexbio.enrichment.rest.model.Task;
import org.ndexbio.enrichment.rest.model.ErrorResponse;
import org.ndexbio.ndexsearch.rest.engine.SearchEngine;
import org.ndexbio.ndexsearch.rest.model.Query;
import org.ndexbio.ndexsearch.rest.model.QueryResults;
import org.ndexbio.ndexsearch.rest.model.QueryStatus;

/**
 * Returns status of Server
 * @author churas
 */
@org.jboss.resteasy.annotations.providers.jaxb.IgnoreMediaTypes("application/*+json")
//@Path(Configuration.REST_PATH)
@Path(Configuration.V_ONE_PATH)
public class Search {
    
    static Logger logger = LoggerFactory.getLogger(Search.class);
    
    /**
     * Returns status of server 
     * @return {@link org.ndexbio.ndexsearch.rest.model.ServerStatus} as JSON
     */
    @POST 
    @Path("/")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = "Submits query",
               description="Payload in JSON will have genelist which is a list of genes and sourceList which is a list of sources to query.\n" +
"The service should upon post return 202 and set location to resource to poll for result. Which will\n" +
"Match the URL of GET request below.",
               responses = {
                   @ApiResponse(responseCode = "202",
                           description = "The task was successfully submitted to the service. Visit the URL "
                                   + "specified in Location field in HEADERS to status and results\n",
                           headers = @Header(name = "Location", description = "URL containing resource generated by this request"),
                           content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = Task.class))),
                   @ApiResponse(responseCode = "500", description = "Server Error",
                                content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = ErrorResponse.class)))
               })
    public Response requestQuery(@RequestBody(description="Query", required = true,
                                                   content = @Content(schema = @Schema(implementation = Query.class))) final String query) {
        ObjectMapper omappy = new ObjectMapper();

        try {
            // not sure why but I cannot get resteasy and jackson to worktogether to
            // automatically translate json to Query class so I'm doing it after the
            // fact
            Query bquery = omappy.readValue(query, Query.class);
            SearchEngine searcher = Configuration.getInstance().getSearchEngine();
            if (searcher == null){
                ErrorResponse er = new ErrorResponse();
                er.setMessage("Configuration error");
                er.setDescription("SearchEngine is null, which is most likely due to configuration error");
                er.setErrorCode("search1");
                return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
            }
            String id = searcher.query(bquery);
            if (id == null){
                throw new NullPointerException("No id returned from search engine");
            }
            Task t = new Task();
            t.setId(id);
			String webURL = Configuration.getInstance().getWebURL();
			if (webURL == null || webURL.equals("")){
				t.setWebURL(null);
			} else {
				t.setWebURL(webURL + id);
			}
            return Response
            		.status(202)
            		.location(new URI(Configuration.getInstance().getHostURL() + Configuration.V_ONE_PATH + "/" + id))
            		.type(MediaType.APPLICATION_JSON)
            		.entity(omappy.writeValueAsString(t))
            		.build();
        } catch(Exception ex){
            ErrorResponse er = new ErrorResponse("Error requesting search", ex);
            return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
        }
    }

    @GET 
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = "Gets result of query",
               description="NOTE: For incomplete/failed jobs only Status, message, progress, and walltime will\n" +
"be returned in JSON",
               responses = {
                   @ApiResponse(responseCode = "200",
                           description = "Success",
                           content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = QueryResults.class))),
                   @ApiResponse(responseCode = "410",
                           description = "Task not found"),
                   @ApiResponse(responseCode = "500", description = "Server Error",
                                content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = ErrorResponse.class)))
               })
    public Response getQueryResults(@PathParam("id") final String id,
            @Parameter(description = "Starting index of result, should be an integer 0 or larger") @QueryParam("start") int start,
            @Parameter(description = "Number of results to return, 0 for all") @QueryParam("size") int size,
            @Parameter(description = "Comma delimited list of sources to return results from For "
                    + "start/size argument, results will be returned in order of listed sources "
                    + "or by order in original query") @QueryParam("source") final String source) {
        ObjectMapper omappy = new ObjectMapper();

        try {
            SearchEngine searcher = Configuration.getInstance().getSearchEngine();
            if (searcher == null){
                ErrorResponse er = new ErrorResponse();
                er.setMessage("Configuration error");
                er.setDescription("SearchEngine is null, which is most likely due to configuration error");
                er.setErrorCode("search2");
                return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
            }
            QueryResults qr = searcher.getQueryResults(id, source, start, size);
            if (qr == null){
                return Response.status(410).build();
            }
            return Response.ok().type(MediaType.APPLICATION_JSON).entity(omappy.writeValueAsString(qr)).build();
        }
        catch(Exception ex){
            ErrorResponse er = new ErrorResponse("Error querying for results", ex);
            return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
        }
    }

    @GET 
    @Path("/{id}/status")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = "Gets status of query",
               description="This lets caller get status without getting the full result back",
               responses = {
                   @ApiResponse(responseCode = "200",
                           description = "Success",
                           content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = QueryStatus.class))),
                   @ApiResponse(responseCode = "410",
                           description = "Task not found"),
                   @ApiResponse(responseCode = "500", description = "Server Error",
                                content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = ErrorResponse.class)))
               })
    public Response getQueryStatus(@PathParam("id") final String id) {
        ObjectMapper omappy = new ObjectMapper();

        try {
            SearchEngine searcher = Configuration.getInstance().getSearchEngine();
            if (searcher == null){
                ErrorResponse er = new ErrorResponse();
                er.setMessage("Configuration error");
                er.setDescription("SearchEngine is null, which is most likely due to configuration error");
                er.setErrorCode("search3");
                return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
            }
            QueryStatus eqs = searcher.getQueryStatus(id);
            if (eqs ==  null){
              return Response.status(410).build();
            }
            return Response.ok().type(MediaType.APPLICATION_JSON).entity(omappy.writeValueAsString(eqs)).build();
        }
        catch(Exception ex){
            ErrorResponse er = new ErrorResponse("Error querying for results", ex);
            return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
        }
    }

    @DELETE 
    @Path("/{id}")
    @Operation(summary = "Deletes task associated with {id} passed in",
               description="",
               responses = {
                   @ApiResponse(responseCode = "200",
                           description = "Delete request successfully received"),
                   @ApiResponse(responseCode = "400",
                           description = "Invalid delete request"),
                   @ApiResponse(responseCode = "500", description = "Server Error",
                                content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = ErrorResponse.class)))
               })
    public Response deleteQueryResult(@PathParam("id") final String id) {

        try {
            SearchEngine searcher = Configuration.getInstance().getSearchEngine();
            if (searcher == null){
                ErrorResponse er = new ErrorResponse();
                er.setMessage("Configuration error");
                er.setDescription("SearchEngine is null, which is most likely due to configuration error");
                er.setErrorCode("search4");
                return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
            }
            searcher.delete(id);
            return Response.status(200).build();
        }
        catch(Exception ex){
            ObjectMapper omappy = new ObjectMapper();
            ErrorResponse er = new ErrorResponse("Error deleting search result", ex);
            return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
        }
    }
    
    @GET 
    @Path("/{id}/overlaynetwork")
    @Operation(summary = "Gets result of from a specific source and network as CX",
               description="NOTE: For incomplete/failed 500 will be returned\n",
               responses = {
                   @ApiResponse(responseCode = "200",
                           description = "Delete request successfully received"),
                   @ApiResponse(responseCode = "410",
                           description = "Task not found"),
                   @ApiResponse(responseCode = "500", description = "Server Error",
                                content = @Content(mediaType = MediaType.APPLICATION_JSON,
                                schema = @Schema(implementation = ErrorResponse.class)))
               })
    public Response getOverlayNetwork(@PathParam("id") final String id, @Parameter(description="UUID of source", required = true) @QueryParam("sourceUUID") final String sourceUUID,
            @Parameter(description="UUID of network", required = true) @QueryParam("networkUUID") final String networkUUID) {
        ObjectMapper omappy = new ObjectMapper();
        InputStream in = null;
        try {
            SearchEngine searcher = Configuration.getInstance().getSearchEngine();
            if (searcher == null){
                ErrorResponse er = new ErrorResponse();
                er.setMessage("Configuration error");
                er.setDescription("SearchEngine is null, which is most likely due to configuration error");
                er.setErrorCode("search5");
                return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
            }
            in = searcher.getNetworkOverlayAsCX(id, sourceUUID, networkUUID);
            if (in == null){
              return Response.status(410).build();
            }
            return Response.ok().type(MediaType.APPLICATION_JSON).entity(in).build();
        }
        catch(Exception ex){
            ErrorResponse er = new ErrorResponse("Error querying for overlay network", ex);
            return Response.serverError().type(MediaType.APPLICATION_JSON).entity(er.asJson()).build();
        }
        /**
         * @TODO CHECK INTO THIS CAUSE IF I INCLUDE A CLOSE THIS DOESNT WORK
        finally {
            if (in != null){
                try {
                    in.close();
                }
                catch(IOException io){
                    logger.error("caught exception trying to close stream", io);
                }
            }
        }
        */
    }
    
}